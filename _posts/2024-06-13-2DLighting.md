---
layout: post
title: åŸºäº2Då¹³é¢å…‰çº¿è¿½è¸ªçš„2Dåœºæ™¯ç…§æ˜
date: 2024-06-13
author: domehall
tags: [Rendering]
comments: true
toc: true
pinned: false
---

ä¸ŠåŠå¹´åšçš„ä¸€ä¸ªç®€å•çš„ã€2Då¹³é¢å…‰è¿½ã€‘ã€ç»“åˆæ·±åº¦åˆ¶ä½œé˜´å½±ã€‘ã€åº”ç”¨äº2Dåœºæ™¯ã€‘çš„æ¢ç´¢æ¡ˆä¾‹ã€‚

é¢„è­¦ï¼šæ–‡ç« åªä»‹ç»æ ¸å¿ƒéƒ¨åˆ†ï¼Œå…¶ä»–ç»†èŠ‚æš‚æ—¶æ‡’å¾—è¡¥å……æ‰€ä»¥è§‚æ„Ÿä¸Šç¼ºèƒ³è†Šå°‘è…¿ï¼›æ¡†å›¾å’Œpptæˆªå›¾å¤§é‡å‘ç”Ÿï¼›ä»£ç å†—é•¿ï¼›è¿™ä¸ªé¡¹ç›®å¯èƒ½æ²¡å¤šå¤§å®é™…æ„ä¹‰ã€‚

<!-- more -->

# æ•´ä½“ä»‹ç»

![2DLighting](https://s2.loli.net/2024/06/13/3oVbprF8MuCZyxn.png)

æœ¬é¡¹ç›®ä»2Då¹³é¢å…‰çº¿è¿½è¸ªï¼ˆè§å‚è€ƒ123ï¼‰å»¶ä¼¸ï¼Œå¼•å…¥æ·±åº¦å®ç°2Dåœºæ™¯å†…çš„ï¼ˆä¼ªï¼‰3Då…‰å½±æ•ˆæœã€‚

åŸºäºUnityå¼•æ“åˆ¶ä½œï¼Œä½¿ç”¨URPæ¸²æŸ“ç®¡çº¿ã€‚é¡¹ç›®æºç ï¼šhttps://gitee.com/domehall/unity-2d-lighting

è¿™é‡Œä¸ä»‹ç»å…·ä½“çš„ç†è®ºæ–¹æ¡ˆè®¾è®¡ï¼Œä»…ä»‹ç»æ ¸å¿ƒè¦ä¹‰ï¼šè¿½è¸ªå…‰çº¿åœ¨äºŒç»´å¹³é¢å†…åˆ©ç”¨äºŒç»´æœ‰å‘è·ç¦»åœºåšå…‰çº¿æ­¥è¿›ï¼Œå¯»æ‰¾è¯¥æ–¹å‘ä¸Šçš„æ‰€æœ‰å…‰æºï¼Œæ¯æ¬¡æ‰¾åˆ°ä¸€ä¸ªå…‰æºåå°±åˆ©ç”¨æ·±åº¦åœ¨ä¼ªä¸‰ç»´ç©ºé—´ä¸­åˆ¤æ–­å…‰çº¿æ˜¯å¦è¢«é˜»æŒ¡ã€‚

## æ¸²æŸ“æµç¨‹

![æ•´ä½“æ¸²æŸ“æµç¨‹](https://s2.loli.net/2024/06/13/V6zAsbuidTFICxy.png)

é—®é¢˜æ¥äº†ï¼Œé—´æ¥å…‰ï¼ˆå…‰çº¿å¼¹å°„ï¼‰æ€ä¹ˆå®ç°ï¼Ÿç®€å•ç²—æš´çš„æ–¹æ³•å¦‚ä¸‹ï¼š

![](https://s2.loli.net/2024/06/13/H9leFut2myOUiTE.png)

## åœ¨Unityå†…å®ç°

![Unityå®ç°æµç¨‹](https://s2.loli.net/2024/06/13/KAIVWCbqseMp2aT.png)

çœ‹ä¸Šå»å¾ˆç®€å•å¯¹ä¸å¯¹ï¼Œå°±æ˜¯è¿™ä¹ˆç®€å•å•¦ã€‚Renderer Featureåªè´Ÿè´£è¾“å…¥å‚æ•°å’Œæ³¨å…¥Pipelineï¼ŒRender Passåªè´Ÿè´£ç®¡ç†å’Œç»˜åˆ¶RTï¼ˆä»¥åŠå…¶ä»–ç›¸æœºè®¾ç½®ä¹‹ç±»çš„ç»†èŠ‚ï¼‰ï¼Œæ‰€ä»¥åæ–‡çš„å®æ–½ç»†èŠ‚å¤§éƒ¨åˆ†éƒ½æ˜¯åœ¨Shaderä¸­çš„ã€‚

ç”¨Compute Shaderçš„åŸå› æ˜¯æƒ³è¯•è¯•æ€§èƒ½ä¼šä¸ä¼šæ›´å¥½ï¼Œé¡ºä¾¿ç»ƒç»ƒæ‰‹ã€‚XD

# Sprite Shader

ç›®å‰åªéœ€è¦ä¸¤ä¸ªpassï¼š
- Universal2Dï¼šé»˜è®¤çš„Sprite.shaderè‡ªå¸¦ï¼Œè¾“å‡ºåŸæœ¬ç‰©ä½“é¢œè‰²`i.color * texColor;`
- Depth2Dï¼šè‡ªå®šä¹‰passï¼Œè¾“å‡ºæ·±åº¦

Depth2Dçš„Fragå‡½æ•°å¦‚ä¸‹ï¼š
```C#
float Frag(Varyings i) : SV_TARGET
{
    Alpha(SampleAlbedoAlpha(i.uv, TEXTURE2D_ARGS(_MainTex, sampler_MainTex)).a, _Color, _Cutoff);
    return i.positionCS.z; //ndc depth
}
```

åœ¨ Render Pass å†…å¯æŒ‰ç…§ä»¥ä¸Šä¸¤ä¸ª Shader Pass å’Œç”¨æˆ·è®¾ç½®çš„ LayerMask åˆ†åˆ«ç»˜åˆ¶ä¸åŒçš„åœºæ™¯ä¿¡æ¯ï¼š

![](https://s2.loli.net/2024/06/13/H9O5mgcKXt2PJex.png)

# è·ç¦»åœº

è¿™é‡Œç”Ÿæˆçš„æ˜¯äºŒç»´æœ‰å‘è·ç¦»åœºã€‚ä½¿ç”¨JFAç®—æ³•ï¼Œäº¤æ›¿ä¸¤ä¸ªRTå»å®æ—¶ç”Ÿæˆè·ç¦»åœºã€‚

![](https://s2.loli.net/2024/06/13/jEvKiD1srJPwocX.png)

Render Passï¼š
```C#
// in Execute()
CopySeed(_depthLSRT, 0);
JumpFlood();
GetDistanceFromJFA(_distLSRT);

private void CopySeed(RTHandle src, int channel)
{
    // channel: 0, 1, 2, 3 - r, g, b, a
    _owner._compute.GetKernelThreadGroupSizes(_owner._kernelSeed, out uint x, out uint y, out uint z);
    Vector3Int dispatchesNum = new Vector3Int(Mathf.CeilToInt((float)_owner._rtRes.x / x), Mathf.CeilToInt((float)_owner._rtRes.y / y), 1);

    _owner._compute.SetTexture(_owner._kernelSeed, "_InputTex", src);
    _owner._compute.SetTexture(_owner._kernelSeed, "_OutputTex", _jfaRT.From);
    _owner._compute.SetFloat("_Channel", channel);
    _owner._compute.Dispatch(_owner._kernelSeed, dispatchesNum.x, dispatchesNum.y, dispatchesNum.z);
}

private void JumpFlood()
{
    _owner._compute.GetKernelThreadGroupSizes(_owner._kernelJFA, out uint x, out uint y, out uint z);
    Vector3Int dispatchesNum = new Vector3Int(Mathf.CeilToInt((float)_owner._rtRes.x / x), Mathf.CeilToInt((float)_owner._rtRes.y / y), 1);
    Vector2Int step = new Vector2Int(_owner._rtRes.x >> 1, _owner._rtRes.y >> 1);
    do
    {
        _owner._compute.SetVector(s_JFAStepSizeId, (Vector2)step);
        _owner._compute.SetTexture(_owner._kernelJFA, "_InputTex", _jfaRT.From);
        _owner._compute.SetTexture(_owner._kernelJFA, "_OutputTex", _jfaRT.To);
        _owner._compute.Dispatch(_owner._kernelJFA, dispatchesNum.x, dispatchesNum.y, dispatchesNum.z);
        _jfaRT.Flip();
        step = new Vector2Int(step.x >> 1, step.y >> 1);
    } while (step.x > 1 || step.y > 1);
}

private void GetDistanceFromJFA(RTHandle dist)
{
    _owner._compute.GetKernelThreadGroupSizes(_owner._kernelDist, out uint x, out uint y, out uint z);
    Vector3Int dispatchesNum = new Vector3Int(Mathf.CeilToInt((float)_owner._rtRes.x / x), Mathf.CeilToInt((float)_owner._rtRes.y / y), 1);

    _owner._compute.SetTexture(_owner._kernelDist, "_InputTex", _jfaRT.From);
    _owner._compute.SetTexture(_owner._kernelDist, "_OutputTex", dist);
    _owner._compute.Dispatch(_owner._kernelDist, dispatchesNum.x, dispatchesNum.y, dispatchesNum.z);
}
```

CopySeed æå–å½¢çŠ¶ï¼š

```C#
[numthreads(8, 8, 1)] void SeedMain(uint3 id : SV_DispatchThreadID)
{
    float alpha = 0;
    switch ((uint)_Channel)
    {
    case 0:
        alpha = _InputTex[id.xy].r;
        break;
    case 1:
        alpha = _InputTex[id.xy].g;
        break;
    case 2:
        alpha = _InputTex[id.xy].b;
        break;
    case 3:
        alpha = _InputTex[id.xy].a;
        break;
    default:
        break;
    }
    float2 posEx = id.xy * (1 - step(alpha, 0));
    float2 posIn = id.xy * step(alpha, 0);
    _OutputTex[id.xy] = float4(posEx, posIn);
}
```

JFAï¼š

```C#
static int2 directions[] = {
    int2(-1, -1),
    int2(-1, 0),
    int2(-1, 1),
    int2(0, -1),
    int2(0, 1),
    int2(1, -1),
    int2(1, 0),
    int2(1, 1)};

void GetMinDistancePoint(uint2 pos, float4 sample, inout float3 minInfoEx, inout float3 minInfoIn)
{
    if (all(sample.xy))
    {
        float distEx = dot(pos - sample.xy, pos - sample.xy);
        if (distEx < minInfoEx.x)
        {
            minInfoEx.x = distEx;
            minInfoEx.yz = sample.xy;
        }
    }
    if (all(sample.zw))
    {
        float distIn = dot(pos - sample.zw, pos - sample.zw);
        if (distIn < minInfoIn.x)
        {
            minInfoIn.x = distIn;
            minInfoIn.yz = sample.zw;
        }
    }
}

[numthreads(8, 8, 1)] void JFAMain(uint3 id : SV_DispatchThreadID)
{
    // external
    float3 minInfoEx = float3(1e16, 0, 0);
    // internal
    float3 minInfoIn = float3(1e16, 0, 0);

    GetMinDistancePoint(id.xy, _InputTex[id.xy], minInfoEx, minInfoIn);
    GetMinDistancePoint(id.xy, _InputTex[id.xy + directions[0] * _JFAStepSize], minInfoEx, minInfoIn);
    GetMinDistancePoint(id.xy, _InputTex[id.xy + directions[1] * _JFAStepSize], minInfoEx, minInfoIn);
    GetMinDistancePoint(id.xy, _InputTex[id.xy + directions[2] * _JFAStepSize], minInfoEx, minInfoIn);
    GetMinDistancePoint(id.xy, _InputTex[id.xy + directions[3] * _JFAStepSize], minInfoEx, minInfoIn);
    GetMinDistancePoint(id.xy, _InputTex[id.xy + directions[4] * _JFAStepSize], minInfoEx, minInfoIn);
    GetMinDistancePoint(id.xy, _InputTex[id.xy + directions[5] * _JFAStepSize], minInfoEx, minInfoIn);
    GetMinDistancePoint(id.xy, _InputTex[id.xy + directions[6] * _JFAStepSize], minInfoEx, minInfoIn);
    GetMinDistancePoint(id.xy, _InputTex[id.xy + directions[7] * _JFAStepSize], minInfoEx, minInfoIn);

    _OutputTex[id.xy] = float4(minInfoEx.yz, minInfoIn.yz);
}
```

GetDistanceï¼š

```C#
[numthreads(8, 8, 1)] void DistMain(uint3 id : SV_DispatchThreadID)
{
    float4 minDistPos = _InputTex[id.xy];
    float distEx = length(id.xy - minDistPos.xy);
    float distIn = length(id.xy - minDistPos.zw);
    _OutputTex[id.xy] = float4(distEx - distIn, 0, 0, 1);
}
```



# å…‰çº¿è¿½è¸ª

## æ­¥è¿›

```C#
// in Trace()
stepLength = GetStepLengthLS(rayPos, stepLength);
rayPos += dir * stepLength;

float GetStepLengthLS(const in float2 pos, const in float lastStepLength)
{
    if (lastStepLength < MINSTEPLENGTH)
        return MINSTEPLENGTH;
    return abs(_LSDistTex[pos]);
}
```

## ä¸å…‰æºçš„ç›¸äº¤æµ‹è¯•

```C#
// in Trace()
const float4 ls = _LightColorTex[rayPos];
if (ls.w > 0)
{
    const float lsDepth = _LSDepthTex[rayPos];
    if (lsDepth - pixelDepth > 0)
    {
        float rayLength2DSquare = dot(pixelPos - rayPos, pixelPos - rayPos);
        float rayLength2D = sqrt(rayLength2DSquare);
        float rayLength = sqrt(rayLength2DSquare + dot(lsDepth - pixelDepth, lsDepth - pixelDepth) * _DepthScale * _DepthScale);
        if (!Shadowed(pixelPos, dir, pixelDepth, lsDepth, rayLength2D))
        {
            lsLight += ls.xyz * ls.w * _LSIntensityMax * Falloff(rayLength, _RMax);
        }
    }
}

bool Shadowed(const in float2 pixelPos, const in float2 dir, const in float pixelDepth, const in float lightDepth, const in float rayLength2D)
{
    float2 shadowRayPos = pixelPos;
    float stepLength = rayLength2D / _ShadowRayStepsNum;
    float blockDepth = pixelDepth;
    for (int n = 0; n < (int)_ShadowRayStepsNum; n++)
    {
        shadowRayPos += dir * stepLength;
        blockDepth = pixelDepth + (lightDepth - pixelDepth) * length(pixelPos - shadowRayPos) / rayLength2D;
        const float depth = _SCDepthTex[shadowRayPos];
        if (depth < blockDepth && depth > blockDepth - EPSILON && depth > lightDepth)
            return true;
    }
    return false;
}
```

å…³äºé˜´å½±é®æŒ¡åˆ¤æ–­å‡½æ•°`Shadowed()`ï¼š

![](https://s2.loli.net/2024/06/13/utYIejLciF1CpGK.png)

- æœ€å¤§æ­¥æ•°ï¼šç”¨æˆ·è¾“å…¥çš„å›ºå®šå€¼ `_ShadowRayStepsNum`
- æ­¥é•¿ï¼š`step = rayLength2D / _ShadowRayStepsNum`
- ğ‘«_ğ’ƒğ’ğ’ğ’„ğ’Œ ï¼š`blockDepth = pixelDepth + (lightDepth - pixelDepth)  * length(pixelPos - shadowRayPos)  / rayLength2D`
- è¢«é˜»æŒ¡æ¡ä»¶ï¼š`depth > blockDepth && depth < blockDepth + EPSILON && depth < lightDepth`

## åƒç´ é¢œè‰²çš„ç»Ÿè®¡é‡‡æ ·

æŠ–åŠ¨åˆ†å±‚é‡‡æ · + ç®€å•ç®—æœ¯å¹³å‡ + ç®€å•çš„å…°ä¼¯ç‰¹æ¼«åå°„æ¨¡å‹ï¼ˆè¿™é‡Œç¯å¢ƒå…‰æ”¹æˆä¸åç…§ç‡ç›¸ä¹˜ï¼‰ã€‚

```C#
for (int i = 0; i < _RaysNum; i++)
{
    const float t = (float(i) + rand) / _RaysNum * float(PI) * 2;
    traceResult += Trace(id.xy, float2(cos(t), sin(t)), depth);
}
traceResult /= _RaysNum;
result = color.xyz * (traceResult + _Ambient);
```

ä½ å¯èƒ½ä¼šæƒ³é—®å…‰æºå’Œå¤©ç©ºèƒŒæ™¯æ€ä¹ˆåŠâ€”â€”å½“ç„¶æ˜¯åœ¨å…‰è¿½å‰åŠ ä¸€ä¸ªåˆ†ç±»å¤„ç†å•¦ã€‚åªä¸è¿‡æˆ‘è¿™é‡Œå†™å¾—å¾ˆæ‹§å·´ï¼Œå°†å°±çœ‹ï¼š

```C#
if (lsDepth - depth > 0 && lsDepth - scDepth > 0)
{
    // Light Source
    result = lerp(color.xyz * _Ambient, lsColor.xyz * _LSIntensityMax * Falloff((1 - lsDepth) * _DepthScale, _RMax), Falloff((1 - lsDepth) * _DepthScale, _RMax)*Falloff((1 - lsDepth) * _DepthScale, _RMax));
}
else if (depth <= 0 || depth > 0 && depth < scDepth)
{
    result = color.xyz * _Ambient;
}
else
{
    //Ray Tracing...
}
```

å‰©ä¸‹çš„â€œæŠŠç€è‰²å®Œæ¯•çš„RT blit åˆ°ç›¸æœºâ€çš„æ­¥éª¤å°±ä¸è¯´äº†ã€‚

# æµ‹è¯•

æµ‹è¯•æ–¹æ³•ï¼šæ‰“åŒ…åä½¿ç”¨Profilerç›‘æµ‹æ•°æ®ã€‚

![Profiler](https://s2.loli.net/2024/06/13/mVGjvHBsyXzxuUg.png)

æµ‹è¯•ç”¨ä¾‹ä¸ç»“æœå¦‚ä¸‹ï¼š

![æ€§èƒ½æµ‹è¯•](https://s2.loli.net/2024/06/13/nRp7H2TgQYNumtC.png)

# èµ›åæ€»ç»“

å…¶å®æ„Ÿè§‰æ²¡å¤šå¤§ç”¨ï¼ˆç¬‘æ­»ï¼‰ã€‚æ€§èƒ½æ˜¯ä¸€èˆ¬ä¸­çš„ä¸€èˆ¬ï¼Œé—´æ¥å…‰æ•ˆæœä¹Ÿä¸å¥½ï¼Œæ²¡å‘æŒ¥å‡ºå…‰è¿½çš„ä¼˜åŠ¿ï¼Œæ‰€ä»¥å¾…ä¼˜åŒ–å§ã€‚

# å‚è€ƒ

1. NullTale - GiLight2Dï¼š https://github.com/NullTale/GiLight2D
2. MiloYip - light2Dï¼šhttps://github.com/miloyip/light2d
3. Jarosz - Theory, analysis and applications of 2d global illuminationï¼šhttps://cs.dartmouth.edu/~wjarosz/publications/jarosz12theory.html
4. å„ç§æ¶‰åŠå®æ—¶æ¸²æŸ“å’Œå…‰çº¿è¿½è¸ªçš„ç»å…¸æ•™æ